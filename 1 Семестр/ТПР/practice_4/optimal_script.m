clc, clear
% %Исходные данные

A0 = [200; 150; 150]; % Запасы на базах A1, A2, A3
B0 = [90; 100; 70; 130; 110]; % Потребности в пунктах B1, B2, B3, B4, B5
C0 = [12, 15, 21, 14, 17; 
      14,  8, 15, 11, 21; 
      19, 16, 26, 12, 20]; % Матрица тарифов

% A0 = [18; 14; 16; 22]; % Запасы на базах A1, A2, A3
% B0 = [8; 11; 11; 9; 21]; % Потребности в пунктах B1, B2, B3, B4, B5
% C0 = [14,  5, 27, 29, 23; 
%       17,  7, 16, 19, 2; 
%       20, 12, 15, 29, 5;
%       14, 24, 18,  7, 14]; % Матрица тарифов

if sum(A0) == sum(B0)
    disp("type: closed")
elseif sum(A0) > sum(B0)
    disp("type: open")
    B0 = [B0; sum(A0) - sum(B0)];
    C0 = [C0 zeros(size(A0,1),1)];
elseif sum(A0) < sum(B0)
    % error
end


A = A0;
B = B0;
C = C0;

% Создание пустой матрицы для плана перевозок
plan = zeros(size(A, 1), size(B, 1));
totalCost = 0; % Переменная для хранения общей стоимости перевозок

% Цикл для заполнения плана перевозок методом минимального элемента
while any(A) && any(B)
    [minCost, minIndex] = min(C(:)); % Находим минимальный тариф
    [i, j] = ind2sub(size(C), minIndex); % Получаем индексы минимального элемcostsента
    
    % Вычисляем количество груза для перевозки
    amount = min(A(i), B(j));
    plan(i, j) = amount; % Заполняем ячейку плана перевозок
    
    % Обновляем остаток груза на базе и в пункте назначения
    A(i) = A(i) - amount;
    B(j) = B(j) - amount;
    
    % Подсчет стоимости для текущей перевозки
    totalCost = totalCost + amount * C(i, j);
    
    % Помечаем использованный тариф как бесконечность
    C(i, j) = inf;
end

disp('План перевозок методом минимального элемента:');
disp(plan);

fprintf('Общая стоимость перевозок: %d\n', totalCost); % Вывод общей стоимости перевозок

A = A0;
B = B0;
C = C0;

% Инициализация переменных
m = numel(A);
n = numel(B);
U = zeros(m, 1); % Потенциалы для баз
V = zeros(n, 1); % Потенциалы для пунктов
totalCost = 0; % Переменная для хранения общей стоимости перевозок
optimalPlan = zeros(m, n); % Пустая матрица для оптимального плана перевозок

% Основной цикл метода потенциалов
while true
    % Поиск потенциалов
    for i = 1:m
        for j = 1:n
            if A(i) > 0 && B(j) > 0
                V(j) = C(i, j) - U(i);
            end
        end
    end
    
    for j = 1:n
        for i = 1:m
            if A(i) > 0 && B(j) > 0
                U(i) = C(i, j) - V(j);
            end
        end
    end
    
    % Нахождение минимальной оценки
    S = inf; % оценка
    for i = 1:m
        for j = 1:n
            if A(i) > 0 && B(j) > 0
                S = min(S, C(i, j) - U(i) - V(j));
            end
        end
    end
    
    % Обновление плана перевозок и подсчет общей стоимости
    for i = 1:m
        for j = 1:n
            if A(i) > 0 && B(j) > 0
                if C(i, j) - U(i) - V(j) == S
                    amount = min(A(i), B(j));
                    A(i) = A(i) - amount;
                    B(j) = B(j) - amount;
                    totalCost = totalCost + amount * C(i, j); % Подсчет стоимости для текущей перевозки
                    optimalPlan(i, j) = amount; % Заполнение оптимального плана перевозок
                end
            end
        end
    end
    
    % Если все запасы и потребности выполнены, выход из цикла
    if S == inf
        break;
    end
end

disp('Оптимальный план перевозок:');
disp(optimalPlan); % Вывод оптимального плана перевозок
fprintf('Общая стоимость перевозок: %d\n', totalCost); % Вывод общей стоимости перевозок после завершения алгоритма